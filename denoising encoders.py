# -*- coding: utf-8 -*-
"""Autoencoders(Vanilla And DENOISING) CIFAR DATASET

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MG4c8JSHJdvOctrwtqbOEgMkBvpilq8A
"""

from keras.datasets import cifar10
from keras.layers import Input, Dense,Conv2D,MaxPooling2D,UpSampling2D,BatchNormalization
from keras.models import Model,Sequential
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

(x_train, _), (x_test, _) = cifar10.load_data()#as i dont need y_train and y_test i kept it blank to prevent downloading them

#flot32 conversion is because the default data type will be unsigned int
x_train = x_train.astype('float32')/255
x_test = x_test.astype('float32')/255

#as shape of the image is (32,32) but to pase the image into the model we should include the channel size also
#thats why we reshaped the shape into (32,32,3)
x_train = x_train.reshape(len(x_train),32,32,3)
x_test = x_test.reshape(len(x_test), 32,32,3)

print(x_train.shape)
print(x_test.shape)

input_img = Input(shape=(32,32,3))

#Encoder
x = Conv2D(16,(3,3), activation='relu', padding='same')(input_img)
x = MaxPooling2D((2,2), padding='same')(x)

x = Conv2D(8,(3,3), activation='relu', padding='same')(x)
x = MaxPooling2D((2,2), padding='same')(x)

x = Conv2D(8,(3,3), activation='relu', padding='same')(x)

encoded = MaxPooling2D((2,2), padding='same', name='encoder')(x)

#Decoder
x = Conv2D(8, (3, 3), activation='relu', padding='same')(encoded)
x = UpSampling2D((2, 2))(x)

x = Conv2D(8, (3, 3), activation='relu', padding='same')(x)
x = UpSampling2D((2, 2))(x)

x = Conv2D(16, (3, 3), activation='relu',padding='same')(x)
x = UpSampling2D((2, 2))(x)

decoded = Conv2D(3, (3, 3), activation='sigmoid', padding='same')(x)

autoencoder = Model(input_img, decoded)
autoencoder.compile(optimizer='adam', loss='mse')

autoencoder.summary()

encoder = Model(input_img, encoded)

encoder.summary()

autoencoder.compile(optimizer='adam', loss='mse', metrics=['accuracy'])

#training the model with same orginal images 
#its likebasic autoencoder training where the output from the orginal imput image as input will be compared/ subtracted with the same original image 
autoencoder.fit(x_train, x_train,
                epochs=10,
                batch_size=256,
                shuffle=True,
                validation_data=(x_test, x_test))

!pip install tensorflow==1.15
!pip install keras==2.2.4

predicted = autoencoder.predict(x_test)

plt.figure(figsize=(40,4))
for i in range(10):
    # display original images
    ax = plt.subplot(3, 20, i + 1)
    plt.imshow(x_test[i].reshape(32, 32,3))
    #plt.gray()
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)
    

    
    # display reconstructed images
    ax = plt.subplot(3, 20, 2*20 +i+ 1)
    plt.imshow(predicted[i].reshape(32, 32,3))
    #plt.gray()
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)
  
    
plt.show()

"""# **DENOSING AUTOENCODERS**"""

from keras.datasets import cifar10
import numpy as np

(X_train, y_train), (X_test, y_test) = cifar10.load_data()

X_train = X_train.astype('float32')
X_test = X_test.astype('float32')

X_train /= 255
X_test /= 255

#multiplying 0.5 with random generated values with loc=0.0 -> mean =0.0 and scale=1.0 -> means standard deviation=1.0

#we are adding noise manually because we dont have inbuiltt noisy images for cifar10 datset
noise_factor = 0.5
x_train_noisy = X_train + noise_factor * np.random.normal(loc=0.0, scale=1.0, size=X_train.shape) 
x_test_noisy = X_test + noise_factor * np.random.normal(loc=0.0, scale=1.0, size=X_test.shape)

#PLOTING NOISY IMAGES BEFORE CLIPPING 
plt.figure(figsize=(20,4))
for i in range(10):
    ax = plt.subplot(2, 10, i + 1)
    plt.imshow(x_test_noisy[i].reshape(32,32,3))
    plt.gray()
plt.show()

"""CLIPPING THE NOISY IMAGES"""

#Clipping the noisy images
#REASON IS EXPLAINED BELOW

#clipping in above code is done to increse the whiteness in the image and decrease greyness in the image 
#ultimately it is used to increase the quality of the image(its done to see an clear image)
#clip function removes the values less than 0. and greater than 1.

x_train_noisy = np.clip(x_train_noisy, 0., 1.)
x_test_noisy = np.clip(x_test_noisy, 0., 1.)

#PLOTTING THE NOISY IMAGES AFTER CLIPPING
plt.figure(figsize=(20,4))
for i in range(10):
    ax = plt.subplot(2, 10, i + 1)
    plt.imshow(x_test_noisy[i].reshape(32,32,3))
    plt.gray()
plt.show()

#We can see more differnce between the noisy images after and before clipping for MNIST DATASET as they are greyscale images

#This code is to compare the noisy images with original images
plt.figure(figsize=(20,4))
for i in range(10):
    ax = plt.subplot(2, 10, i + 1)
    plt.imshow(x_test_noisy[i].reshape(32,32,3))
    plt.gray()
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)
plt.show()
plt.figure(figsize=(20,4))
for i in range(10):
    ax = plt.subplot(2, 10, i + 1)
    plt.imshow(X_test[i].reshape(32,32,3))
    plt.gray()
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)
plt.show()

#passing noisy images and original images into the model
#as after every epoch here the recontructed image of the noisy image input will be compared with the orginal image to calculate the loss
autoencoder.fit(x_train_noisy,x_train,epochs=10,batch_size=256,shuffle=True,validation_data=(x_test_noisy,x_test))

autoencoder.evaluate(x_test_noisy, x_test)
autoencoder.save('denoising_autoencoder.model')

no_noise_img = autoencoder.predict(x_test_noisy)

#plotting the noisy images and denoised images
plt.figure(figsize=(40, 4))
for i in range(10):
    # display original
    ax = plt.subplot(3, 20, i + 1)
    plt.imshow(x_test_noisy[i].reshape(32, 32,3), cmap="binary")
    
    # display reconstructed (after noise removed) image
    ax = plt.subplot(3, 20, 40 +i+ 1)
    plt.imshow(no_noise_img[i].reshape(32, 32,3), cmap="binary")

plt.show()

#differnt code to plot above same images
plt.figure(figsize=(20,4))
for i in range(10):
    ax = plt.subplot(2, 10, i + 1)
    plt.imshow(x_test_noisy[i].reshape(32,32,3))
    plt.gray()
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)
plt.show()
plt.figure(figsize=(20,4))
for i in range(10):
    ax = plt.subplot(2, 10, i + 1)
    plt.imshow(no_noise_img[i].reshape(32,32,3))
    plt.gray()
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)
plt.show()

# Commented out IPython magic to ensure Python compatibility.
# %%shell
# jupyter nbconvert --to html /content/Autoencoders_cifar10.ipynb